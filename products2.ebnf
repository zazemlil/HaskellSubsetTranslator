#{ 5 
S -> DEFINITIONS

DEFINITIONS -> DEFINITION DEFINITIONS`
DEFINITIONS` -> DEFINITION DEFINITIONS`
        | ε

DEFINITION -> SIGNATURE SUPERCOMBINATOR
        | DATA_TYPE_DECL

SIGNATURE -> id "::" DATA_TYPE_SIGNATURE
#} 5


#{ 6
TYPE_SIGNATURE -> TYPE TYPE_SIGNATURE`
TYPE_SIGNATURE` -> "->" TYPE TYPE_SIGNATURE`
        | ε

TYPE -> SIMPLE_TYPE
        | "(" TYPE_SIGNATURE ")"

SIMPLE_TYPE -> "Int"
        | "Float"
        | "literal_char"
        | "Bool"
        | LIST_TYPE
        | type_constructor TYPE_ARGUMENTS

LIST_TYPE -> "[" TYPE "]"

TYPE_ARGUMENTS -> TYPE TYPE_ARGUMENTS
        | ε
#} 6


#{ 7
SUPERCOMBINATOR -> FUNCTION_DECL
        |  VARIABLE_DECL

FUNCTION_DECL -> id PATTERNS "=" EXPR FUNCTION_DECL`
FUNCTION_DECL` -> id PATTERNS "=" EXPR FUNCTION_DECL`
        | ε
VARIABLE_DECL -> id "=" EXPR
#} 7


#{ 8 (нужно ли параметризованное определение?)
DATA_TYPE_DECL -> "data" type_constructor TYPE_DECL
TYPE_DECL -> "=" CONSTRUCTORS
        | TYPE_PARAMETERS "=" CONSTRUCTORS

TYPE_PARAMETERS -> type_constructor TYPE_PARAMETERS`
TYPE_PARAMETERS` -> type_constructor TYPE_PARAMETERS`
        | ε

CONSTRUCTORS -> CONS CONSTRUCTORS`
CONSTRUCTORS` -> "|" CONS CONSTRUCTORS`
        | ε
CONS -> type_constructor 
        | type_constructor FIELD_TYPES
FIELD_TYPES -> TYPE FIELD_TYPES`
FIELD_TYPES` -> TYPE FIELD_TYPES`
        | ε
#} 8


#{ 4
PATTERNS -> PATTERN PATTERNS`
PATTERNS` -> PATTERN PATTERNS`
        | ε

PATTERN -> id
        | LITERAL
        | "_"
        | CONSTRUCTOR_PATTERN
        | LIST_PATTERN

CONSTRUCTOR_PATTERN -> type_constructor PATTERNS
        | type_constructor

LIST_PATTERN -> "[" LIST_PATTERNS "]"
        | "(" id ":" id ")"
LIST_PATTERNS -> PATTERN LIST_PATTERNS`
        | ε
LIST_PATTERNS` -> "," PATTERN LIST_PATTERNS`
        | ε
#} 4


#{ 3
LIST_COMPREHENSION -> "[" EXPR "|" QUALIFIERS "]"
QUALIFIERS -> QUALIFIER QUALIFIERS`
QUALIFIERS` -> "," QUALIFIER QUALIFIERS`
        | ε
QUALIFIER -> id "<-" EXPR
        | EXPR
#} 3


#{ 2
LET_EXPR -> "let" BINDINGS "in" EXPR
IF_EXPR -> "if" EXPR "then" EXPR "else" EXPR
LAMBDA_EXPR -> "\\" PATTERNS "->" EXPR

BINDINGS -> BIND BINDINGS`
BINDINGS` -> "," BIND BINDINGS`
        | ε
BIND -> id "=" EXPR 
        | id PATTERNS "=" EXPR 
#} 2


#{ 9
INFIX_EXPR -> AND_EXPR OR_EXPR
OR_EXPR -> "||" AND_EXPR OR_EXPR
        | ε

AND_EXPR -> COMP_EXPR AND_EXPR`
AND_EXPR` -> "&&" COMP_EXPR AND_EXPR`
        | ε

COMP_EXPR -> ADDITIVE_EXPR COMP_EXPR`
COMP_EXPR` -> COMP_OP ADDITIVE_EXPR COMP_EXPR`
        | ε
COMP_OP -> "==" | "/=" | "<" | ">" | "<=" | ">="

ADDITIVE_EXPR -> MULTIPLICATIVE_EXPR ADDITIVE_EXPR`
ADDITIVE_EXPR` -> ADDITIVE_OP MULTIPLICATIVE_EXPR ADDITIVE_EXPR`
        | ε
ADDITIVE_OP -> "+" | "-"

MULTIPLICATIVE_EXPR -> TERM MULTIPLICATIVE_EXPR`
MULTIPLICATIVE_EXPR` -> MULTIPLICATIVE_OP TERM MULTIPLICATIVE_EXPR`
        | ε
MULTIPLICATIVE_OP -> "*" | "/"

TERM -> LITERAL
        | id
        | type_constructor
        | LIST_COMPREHENSION
        | "(" EXPR ")"
        | "[" LIST_ELEMENTS "]"
        | "(" FUNCTION_CALL ")"

LIST_ELEMENTS -> EXPR LIST_ELEMENTS`
        | ε
LIST_ELEMENTS` -> "," EXPR LIST_ELEMENTS`
        | ε

FUNCTION_CALL -> id ARG_LIST
ARG_LIST -> "(" ARG_LIST1 ")"
        | TERM
ARG_LIST1 -> EXPR ARG_LIST2
        | ε
ARG_LIST2 -> "," EXPR ARG_LIST2
        | ε
#} 9


#{ 1
EXPR -> LET_EXPR
        | IF_EXPR
        | LAMBDA_EXPR
        | LIST_COMPREHENSION
        | INFIX_EXPR


LITERAL -> literal_int
        | literal_float
        | literal_char
        | "True"
        | "False"

id -> [a-z][a-zA-z|0-9]*
type_constructor -> [A-Z][a-zA-z|0-9]*
literal_int -> [-]?[0-9]+
literal_float -> [-]?[0-9]+"."[0-9]+
literal_char -> "'"[a-zA-z|0-9]"'"

#} 1

# нужен ли case of? 
# нужно ли параметризованное определение (data Maybe a = Nothing | Just a)?
# в некоторых случаях без левой факторизации. может ее вообще убрать (для удобства чтения)?
# ошибка после добавления продукции FUNCTION_CALL:
#  .././src/grammar.y: warning: 1 shift/reduce conflict [-Wconflicts-sr]
#  .././src/grammar.y: warning: shift/reduce conflict on token T_PARENTHESIS_CLOSE [-Wcounterexamples]
#    Example: T_PARENTHESIS_OPEN expr • T_PARENTHESIS_CLOSE
#    Shift derivation
#      arg_list
#      ↳ 39: term
#            ↳ 30: T_PARENTHESIS_OPEN expr • T_PARENTHESIS_CLOSE
#    Reduce derivation
#      arg_list
#      ↳ 38: T_PARENTHESIS_OPEN arg_list1            T_PARENTHESIS_CLOSE
#                               ↳ 40: expr arg_list2
#                                          ↳ 43: ε •